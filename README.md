# ePortfolio

- [ePortfolio](#eportfolio)
  - [Plan 0](#plan-0)
    - [1Ô∏è‚É£ **Aufgabe 1: Definiere den Begriff Algorithmus und kl√§re seine Herkunft**](#1Ô∏è‚É£-aufgabe-1-definiere-den-begriff-algorithmus-und-kl√§re-seine-herkunft)
    - [2Ô∏è‚É£ **Aufgabe 2: Betrachte das Bild Tellersp√ºlen und stelle den Algorithmus grafisch dar**](#2Ô∏è‚É£-aufgabe-2-betrachte-das-bild-tellersp√ºlen-und-stelle-den-algorithmus-grafisch-dar)
  - [Plan 1](#plan-1)
    - [üåê Tiefgang 1: Navigation und Algorithmen](#-tiefgang-1-navigation-und-algorithmen)
      - [üìå Aufgabe](#-aufgabe)
      - [üîç Brute Force](#-brute-force)
        - [üìã Vorgehen:](#-vorgehen)
      - [üß† Mensch vs ü§ñ Computer](#-mensch-vs--computer)
        - [ü§ñ **Computer**:](#-computer)
        - [üß† **Mensch**:](#-mensch)
      - [‚ö†Ô∏è Problematik bei 100 St√§dten](#Ô∏è-problematik-bei-100-st√§dten)
    - [Tiefgang 2](#tiefgang-2)
      - [1Ô∏è‚É£ Abstrakte Abbildung der U-Bahnlinie](#1Ô∏è‚É£-abstrakte-abbildung-der-u-bahnlinie)
      - [2Ô∏è‚É£ Relevanzbewertung der Karteninformationen](#2Ô∏è‚É£-relevanzbewertung-der-karteninformationen)
      - [3Ô∏è‚É£ Abstrakte Darstellung der Karte](#3Ô∏è‚É£-abstrakte-darstellung-der-karte)
      - [4Ô∏è‚É£ Feinabstimmung durch Gleichformung](#4Ô∏è‚É£-feinabstimmung-durch-gleichformung)
    - [üåç Tiefgang 3 - Dijkstra und die Ameisen](#-tiefgang-3---dijkstra-und-die-ameisen)
      - [üêú Wie ermitteln wir den k√ºrzesten Weg von Imstadt nach Oppenheim?](#-wie-ermitteln-wir-den-k√ºrzesten-weg-von-imstadt-nach-oppenheim)
      - [1Ô∏è‚É£ **Frage 1:** Wohin gelangt ihr nach 7 Minuten?](#1Ô∏è‚É£-frage-1-wohin-gelangt-ihr-nach-7-minuten)
      - [2Ô∏è‚É£ **Frage 2:** Wie geht es weiter?](#2Ô∏è‚É£-frage-2-wie-geht-es-weiter)
        - [K√ºrzeste Strecke von Imstadt nach Oppenheim](#k√ºrzeste-strecke-von-imstadt-nach-oppenheim)
        - [üìê Dijkstra-Algorithmus: Der Weg zur Effizienz](#-dijkstra-algorithmus-der-weg-zur-effizienz)
          - [üöÄ Was ist der Dijkstra-Algorithmus?](#-was-ist-der-dijkstra-algorithmus)
          - [üîç Wie funktioniert der Dijkstra-Algorithmus?](#-wie-funktioniert-der-dijkstra-algorithmus)
          - [üìã Schritte:](#-schritte)
    - [Tiefgang 4 von Lupera (J) nach Eindhofen (E)](#tiefgang-4-von-lupera-j-nach-eindhofen-e)
      - [Grafische Darstellung](#grafische-darstellung)
    - [Tiefgang 5](#tiefgang-5)
  - [Exkurs Graph](#exkurs-graph)
  - [Berechnung der Fahrzeiten](#berechnung-der-fahrzeiten)
    - [Gegebene Geschwindigkeiten:](#gegebene-geschwindigkeiten)
    - [Fahrzeitberechnung](#fahrzeitberechnung)
      - [1. Imstadt nach Budingen (7 km, Landstra√üe, 80 km/h)](#1-imstadt-nach-budingen-7-km-landstra√üe-80-kmh)
      - [2. Imstadt nach Chelzey (8,2 km, Gemeindestra√üe, 50 km/h)](#2-imstadt-nach-chelzey-82-km-gemeindestra√üe-50-kmh)
      - [3. Imstadt nach Morbach (9,0 km, Landstra√üe, 80 km/h)](#3-imstadt-nach-morbach-90-km-landstra√üe-80-kmh)
      - [4. Imstadt nach Hundorf (13,4 km, Gemeindestra√üe, 50 km/h)](#4-imstadt-nach-hundorf-134-km-gemeindestra√üe-50-kmh)
      - [5. Imstadt nach Pappstadt (10,5 km, Landstra√üe, 80 km/h)](#5-imstadt-nach-pappstadt-105-km-landstra√üe-80-kmh)
    - [Hinweis zu Ortsdurchfahrten:](#hinweis-zu-ortsdurchfahrten)

---

## Plan 0

### 1Ô∏è‚É£ **Aufgabe 1: Definiere den Begriff Algorithmus und kl√§re seine Herkunft**

üìå **Begriffserkl√§rung:**  
Ein **Algorithmus** ist eine systematische, endliche Folge von Anweisungen, die ein bestimmtes Problem l√∂sen oder eine Aufgabe erf√ºllen. Er zeichnet sich durch folgende Merkmale aus:
- üîÑ **Endlichkeit**: Der Algorithmus hat ein klares Ende.
- ‚úîÔ∏è **Eindeutigkeit**: Jede Anweisung ist pr√§zise und eindeutig.
- ‚öôÔ∏è **Ausf√ºhrbarkeit**: Jede Anweisung muss technisch umsetzbar sein.
- üîÄ **Determinismus**: Der Algorithmus f√ºhrt immer zum gleichen Ergebnis, wenn die gleichen Eingabedaten vorliegen.

üìö **Herkunft:**  
Der Begriff stammt von dem persischen Mathematiker **al-Chwarizmi** (ca. 780‚Äì850 n. Chr.), dessen Werke zur Algebra und Mathematik die Grundlage f√ºr systematische Verfahren bildeten.  
Der Name "Algorithmus" leitet sich von der Latinisierung seines Namens **Algoritmi** ab und wurde sp√§ter auf alle strukturierten Probleml√∂sungsverfahren angewendet.

---

### 2Ô∏è‚É£ **Aufgabe 2: Betrachte das Bild Tellersp√ºlen und stelle den Algorithmus grafisch dar**

üìå **Aufgabe:**  
Stelle den Algorithmus zum Tellersp√ºlen grafisch dar, indem du f√ºr Start und Ende ein Oval verwendest, f√ºr Anweisungen ein Rechteck und bei Entscheidungen eine Raute.  

```mermaid
flowchart TD
    
    A((Start)) --> B{Sp√ºlmittel fast leer?}
    B -->|Ja| E[ Sp√ºlmittel wechseln]
    B -->|Nein| D[Teller nehmen]
    D -->DE[Teller waschen]
    DE --> F{Sind alle Teller gewaschen?}
    E --> D
    F -->|Ja| H{Schwamm schmutzig?}
    H -->|Ja| I[Schwamm reinigen]
    H -->|Nein| J((Ende))
    I --> J
    F--> |Nein| B
```

## Plan 1

### üåê Tiefgang 1: Navigation und Algorithmen  

#### üìå Aufgabe  

Hier tauchen wir in die Tiefe der Navigation ein. Schritt f√ºr Schritt werden wir abstrakter und gelangen zu einem Algorithmus f√ºr die **k√ºrzeste Strecke**.  

Das Material stammt aus dem Buch [Abenteuer Informatik](https://abenteuer-informatik.de/), zu dem es auch eine Webseite gibt!  

---

#### üîç Brute Force  

**Definition**: Brute Force ist eine Methode, bei der **alle m√∂glichen Kombinationen** durchprobiert werden, um eine optimale L√∂sung zu finden.  

##### üìã Vorgehen:  
- Alle m√∂glichen Wege von **Imstadt** nach **Oppenheim** durchspielen.  
- Die Gesamtdistanz jedes Weges berechnen.  
- Den k√ºrzesten Weg ermitteln.  

Alle m√∂glichen Verbindungen:

```mermaid
flowchart TD
    A[Quickstedt]
    B[Oppenheim]
    C[Pappstadt]
    D[Fluxing]
    E[Eindhofen]
    F[Imstadt]
    G[Hundorf]
    H[Krusping]
    I[Giwelau]
    J[Lupera]
    K[Budingen]
    L[Morbach]
    M[Chelzey]
    N[Delgar]
    O[Arlhausen]
    P[Niedergau]
    AK1(Autobahnkreuz 1)
    AK2(Autobahnkreuz 2)
    AK3(Autobahnkreuz 3)
    
    A -->|5,3‚Ç¨| B
    B -->|18,2‚Ç¨| C
    B -->|2,9‚Ç¨| D
    B -->|19,5‚Ç¨| E
    C -->|11,6‚Ç¨| D
    C -->|15,4‚Ç¨| F
    C -->|10,5‚Ç¨| F
    C -->|7,1‚Ç¨| G
    C -->|7,1‚Ç¨| H
    D -->|15,6‚Ç¨| E
    D -->|6,1‚Ç¨| H
    E -->|12,1‚Ç¨| I
    E -->|6,2‚Ç¨| H
    F -->|13,4‚Ç¨| G
    F -->|7,0‚Ç¨| K
    F -->|9,0‚Ç¨| L
    F -->|9,0‚Ç¨| M
    G --> |6,0‚Ç¨| H
    G --> |5,9‚Ç¨| AK1 
    G --> |21,1‚Ç¨| J 
    G --> |5,6‚Ç¨| K
    H --> |11,5‚Ç¨| I
    H --> |3,6‚Ç¨| AK1
    I--> |11,8‚Ç¨| J
    I--> |5,5‚Ç¨| AK1
    J --> |18,9‚Ç¨| N
    J --> |7,8‚Ç¨| AK2
    K --> |6,2‚Ç¨| AK2
    K --> |4,9‚Ç¨| AK3
    K --> |13,0‚Ç¨| N
    K --> |14,3‚Ç¨| O
    L --> |5,6‚Ç¨| M
    L --> |6,7‚Ç¨| O
    L --> |2,3‚Ç¨| AK3
    M --> |4,6‚Ç¨| AK3
    N --> |2,5‚Ç¨| N
    N --> |6,6‚Ç¨| O
    N --> |6,6‚Ç¨| O
    N --> |4,1‚Ç¨| P
    O --> |3,8‚Ç¨| P
    O --> |5,8‚Ç¨| AK2
    O --> |6,4‚Ç¨| AK3
    AK1 --> |4,5‚Ç¨| AK2
```

1. Initialisierung: Der Startpunkt ist Imstadt (F) und das Ziel ist Oppenheim (B).
2. Wegfindung: Alle m√∂glichen Verbindungen von Imstadt (F) werden verfolgt.

- Von `F` gibt es folgende Verbindungen:
    - `F` ‚Üí `G` (Kosten: 13,4‚Ç¨)
    - `F` ‚Üí `K` (Kosten: 7,0‚Ç¨)
    - `F` ‚Üí `L` (Kosten: 9,0‚Ç¨)
    - `F` ‚Üí `M` (Kosten: 9,0‚Ç¨)
3. Exploration der m√∂glichen Wege: Der Algorithmus √ºberpr√ºft alle Wege, die von den Nachbarst√§dten ausgehen:
    - **Pfad 1:** `F` ‚Üí `G` ‚Üí `H` ‚Üí `I` ‚Üí `J` ‚Üí `N` ‚Üí `P` ‚Üí `O` ‚Üí `P` ‚Üí `O` ‚Üí `AK1` ‚Üí `AK2` ‚Üí `B`.
        ```mermaid
        flowchart TD
            F[Imstadt]
            G[Hundorf]
            H[Krusping]
            I[Giwelau]
            J[Lupera]
            N[Delgar]
            P[Niedergau]
            O[Arlhausen]
            AK1[Autobahnkreuz 1]
            AK2[Autobahnkreuz 2]
            B[Oppenheim]
            
            F -->|13,4‚Ç¨| G
            G -->|6,0‚Ç¨| H
            H -->|11,5‚Ç¨| I
            I -->|11,8‚Ç¨| J
            J -->|18,9‚Ç¨| N
            N -->|4,1‚Ç¨| P
            P -->|6,6‚Ç¨| O
            O -->|3,8‚Ç¨| P
            P -->|6,6‚Ç¨| O
            O -->|4,5‚Ç¨| AK1
            AK1 -->|4,5‚Ç¨| AK2
            AK2 -->|18,9‚Ç¨| B
        ```
    - **Pfad 2:** `F` ‚Üí `K` ‚Üí `O` ‚Üí `B`.
        ```mermaid
        flowchart TD
            F[Imstadt]
            K[Budingen]
            O[Arlhausen]
            B[Oppenheim]
            
            F -->|7,0‚Ç¨| K
            K -->|14,3‚Ç¨| O
            O -->|5,8‚Ç¨| B
        ```
    - **Pfad 3:** `F` ‚Üí `M` ‚Üí `P` ‚Üí `B`.
        ```mermaid
            flowchart TD
                F[Imstadt]
                K[Budingen]
                O[Arlhausen]
                B[Oppenheim]
                
                F -->|7,0‚Ç¨| K
                K -->|14,3‚Ç¨| O
                O -->|5,8‚Ç¨| B
        ```

4. Berechnung der Kosten f√ºr jeden Pfad:
    - **Pfad 1**:
        - Kosten: 13,4+6,0+11,5+11,8+18,9+4,1+6,6+3,8+6,6+4,5+4,5+18,9=111,6‚Ç¨
    - **Pfad 2**:
        - Kosten: 7,0‚Ç¨ + 14,3‚Ç¨ + 5,8‚Ç¨ = 27,1‚Ç¨
    - **Pfad 3**:
        - Kosten: 9,0‚Ç¨ + 4,1‚Ç¨ + 6,6‚Ç¨ + 5,8‚Ç¨ = 25,5‚Ç¨
5. Vergleichen und Finden des g√ºnstigsten Weges:

Der g√ºnstigste Weg w√§re in diesem Fall der **Pfad 3** mit den Kosten von `25,5`‚Ç¨.

---

#### üß† Mensch vs ü§ñ Computer  

##### ü§ñ **Computer**:  
- Kann systematisch und effizient **alle Wege berechnen**.  
- Vorteilhaft bei gro√üen Datenmengen: schneller und weniger fehleranf√§llig.  

##### üß† **Mensch**:  
- Kann sinnvolle **Heuristiken** oder Ausschlusskriterien anwenden (z. B. k√ºrzere Strecken bevorzugen).  
- Versteht den **Kontext** besser und kann priorisieren.  

---

#### ‚ö†Ô∏è Problematik bei 100 St√§dten  

- Die Anzahl der m√∂glichen Wege **steigt exponentiell** (Kombinatorik).  
- Der **Brute-Force-Ansatz** wird unpraktikabel, da die Berechnungszeit enorm zunimmt.  
- Effiziente Algorithmen wie der **Dijkstra-Algorithmus** sind notwendig.  

---

### Tiefgang 2

#### 1Ô∏è‚É£ Abstrakte Abbildung der U-Bahnlinie

üìå **Aufgabe:**  
Notiere 3‚Äì4 Informationen, die in der abstrakten Darstellung weggelassen wurden:  
- üîÑ **Umsteigem√∂glichkeiten**
  - üé® Farbcode  
- üïí **Betriebszeiten**  
- üéüÔ∏è **Fahrkarteninformationen**  
- üöß **Besondere Hinweise**
  - üõ†Ô∏è Baustellen  
  - ‚û°Ô∏è Umleitungen  

---

#### 2Ô∏è‚É£ Relevanzbewertung der Karteninformationen
Erstelle eine Liste mit allen Informationen aus der Karte aus **Tiefgang 1** und bewerte diese nach Relevanz f√ºr die L√∂sung: **Finde die g√ºnstigste Strecke!**  

| üóÇÔ∏è **Eigenschaft**                   | ‚úîÔ∏è **Wichtig?** | üí° **Begr√ºndung**                                                       |
| ----------------------------------- | -------------- | ---------------------------------------------------------------------- |
| üèôÔ∏è **Namen der St√§dte**              | ‚úîÔ∏è Ja           | Start und Ziel sind entscheidend.                                      |
| üìç **Position der St√§dte**           | ‚ùå Nein         | Nicht relevant ‚Äì es geht nur um Kosten, nicht um Zeit oder Entfernung. |
| üåÜ **Gr√∂√üe der St√§dte**              | ‚ùå Nein         | Keine Auswirkung auf das Problem.                                      |
| üõ§Ô∏è **Verlauf der Stra√üen**           | ‚ùå Nein         | Nicht relevant ‚Äì Zugfahrt steht im Fokus.                              |
| üìè **L√§nge der Stra√üen**             | ‚ùå Nein         | Kosten sind ausschlaggebend, nicht Zeit oder Entfernung.               |
| üõ£Ô∏è **Namen und Nummern der Stra√üen** | ‚ùå Nein         | Nicht notwendig f√ºr die Kostenermittlung.                              |
| üöó **Stra√üentyp**                    | ‚ùå Nein         | Keine Relevanz f√ºr die Kostenberechnung.                               |
| ‚ÜîÔ∏è **Stra√üe f√ºhrt von... nach...**   | ‚ùå Nein         | Nicht relevant f√ºr Kostenanalyse.                                      |
| üå≥ **Landschaftliche Informationen** | ‚ùå Nein         | Keine Bedeutung f√ºr die Aufgabe.                                       |
| üí∞ **Kosten zwischen X und Y**       | ‚úîÔ∏è Ja           | Wichtiger Faktor zur Ermittlung der g√ºnstigsten Strecke.               |

---

#### 3Ô∏è‚É£ Abstrakte Darstellung der Karte

üìå **Aufgabe:**  
√úberf√ºhre die Karte in eine vereinfachte Darstellung wie eine **U-Bahn-Karte**:  
- ‚úÇÔ∏è K√ºrze unn√∂tige Details wie Kreuzungen, Abfahrten oder √úberf√ºhrungen.  
- üé® Zeichne einen Flowgraphen (siehe Abschnitt [Vorgehen](#vorgehen)).

---

#### 4Ô∏è‚É£ Feinabstimmung durch Gleichformung

üìå **Aufgabe:**  
Bearbeite die Karte mit der Methode der **Gleichformung**:  
- üîç Unterscheide zwischen **normalen** und **spezialisierten** Elementen.  
- üõ†Ô∏è **Normalisiere spezielle Elemente**, sodass nur n√ºtzliche Informationen √ºbrigbleiben.  
- ‚û°Ô∏è Abgleich der Informationen mit der Tabelle oben, um irrelevante Details zu entfernen.  

---
### üåç Tiefgang 3 - Dijkstra und die Ameisen

#### üêú Wie ermitteln wir den k√ºrzesten Weg von Imstadt nach Oppenheim?

Wir k√∂nnen uns dabei von der Natur inspirieren lassen. Ein Stamm Ameisen auf der Suche nach Futter steht vor einem √§hnlichen Problem: Eine Kundschafterin findet ein gro√ües St√ºck Fleisch. Welchen Weg sollen die Arbeiterinnen nehmen, um das Futter schnell zu erreichen?

Setzen wir also die Ameisen auf den Ausgangspunkt **Imstadt** (‚íæ). F√ºnf Wege f√ºhren von dort weg, also teilen sich unz√§hlige Ameisen auf, um diese zu erkunden. Angenommen, alle Ameisen sind gleich schnell (1 km pro Minute). Mit dem Finger verfolgen wir den Weg der Ameisen.

---

#### 1Ô∏è‚É£ **Frage 1:** Wohin gelangt ihr nach 7 Minuten?

üìå **Aufgabe:**  
F√§rbt auf der Karte die Wege der Ameisen ein und betrachtet das Bild nach ‚Äû7 min‚Äú. Was bedeutet das? Speichert ein Bild der Karte als Zwischenstand und formuliert einen Antwortsatz.

![SVG Image](./assets/images/plan_1_tiefgang_3.drawio.svg)

---

#### 2Ô∏è‚É£ **Frage 2:** Wie geht es weiter?

Die Ameisen setzen ihren Weg fort und teilen sich bei B so auf, dass jeder m√∂gliche Weg von B aus mit einem neuen Trupp Ameisen beschickt wird. Wenn ein Trupp an einem Ort zuerst ankommt, bedeutet das, dass dieser Weg der schnellste ist.

```mermaid
graph TD
    F((F)) -->|13.4| G((G))
    F -->|7.0| K((K))
    F -->|9.0| L((L))
    F -->|9.0| M((M))
    G -->|19.0| H((H))
    G -->|5.9| AK1((AK1))
    G -->|21.1| J((J))
    G -->|5.6| K
    K -->|6.2| AK2((AK2))
    K -->|4.9| AK3((AK3))
    K -->|13.0| N((N))
    K -->|14.3| O((O))
    L -->|5.6| M
    L -->|6.7| O
    L -->|2.3| AK3
    M -->|4.6| AK3
    H -->|11.5| I((I))
    H -->|3.6| AK1
    I -->|11.8| J
    I -->|5.5| AK1
    J -->|18.9| N
    J -->|7.8| AK2
    AK1 -->|4.5| AK2
    AK3 -->|6.4| O
    O -->|3.8| P((P))
    O -->|5.8| AK2
    O -->|6.4| AK3
    P -->|2.5| N
    N -->|6.6| O
    N -->|4.1| P
    B((B))

    %% Highlight the shortest path
    classDef highlight fill:#f96,stroke:#333,stroke-width:2px;
    F -->|7.0| K
    K -->|6.2| AK2
    AK2 -->|7.8| J
    J -->|18.9| N
    N -->|4.1| P
    P -->|3.8| O
    O -->|5.8| B
    class F,K,AK2,J,N,P,O,B highlight;
```
##### K√ºrzeste Strecke von Imstadt nach Oppenheim

üìå **Berechnung der Strecke:**  
Die k√ºrzeste Strecke von F(Imstadt) nach B(Oppenheim) betr√§gt **24,8 Einheiten**, und der Pfad lautet:  
`F ‚Üí G ‚Üí H ‚Üí AK1 ‚Üí AK2 ‚Üí B`

---

##### üìê Dijkstra-Algorithmus: Der Weg zur Effizienz

###### üöÄ Was ist der Dijkstra-Algorithmus?  
Der **Dijkstra-Algorithmus** ist ein Graph-Suchalgorithmus, der den **k√ºrzesten Weg** von einem Startknoten zu allen anderen Knoten in einem Graphen findet.

###### üîç Wie funktioniert der Dijkstra-Algorithmus?

###### üìã Schritte:

1. **Initialisierung:**
   - Setze die Distanz zum Startknoten auf `0`.
   - Alle anderen Knoten erhalten die Distanz `‚àû` (unendlich).

2. **Besuche den n√§chsten Knoten:**
   - W√§hle den Knoten mit der **geringsten aktuellen Distanz**, der noch nicht besucht wurde.

3. **Aktualisiere Distanzen:**
   - Berechne die Distanz zu allen benachbarten Knoten.
   - Aktualisiere die Distanz, falls sie k√ºrzer ist als der bisher bekannte Wert.

4. **Wiederhole:**
   - Fahre fort, bis alle Knoten besucht wurden oder das Ziel erreicht ist.

```mermaid
flowchart TD
    Start((Start)) --> Init["Initialisiere alle Knoten: Abstand = ‚àû, Vorg√§nger = undefiniert"]
    Init --> SetStart["Setze Startknoten (z. B. F): Abstand = 0"]
    SetStart --> ProcessQueue{"Gibt es noch unbesuchte Knoten?"}

    ProcessQueue -->|Ja| SelectNode["W√§hle unbesuchten Knoten mit kleinstem Abstand"]
    SelectNode --> UpdateNeighbors["Aktualisiere die Nachbarn des aktuellen Knotens"]
    UpdateNeighbors --> MarkVisited["Markiere aktuellen Knoten als besucht"]
    MarkVisited --> ProcessQueue

    ProcessQueue -->|Nein| EndCheck{"Ist der Zielknoten erreicht?"}
    EndCheck -->|Ja| End((Ende: K√ºrzester Weg gefunden))
    EndCheck -->|Nein| Error("Fehler: Kein erreichbarer Weg")
```


**Pseudocode Beispiel**
```
1. function Dijkstra(Graph, source):
2.     dist = {}
3.     prev = {}
4.     Q = priority queue of all nodes in Graph
5.     
6.     for each node v in Graph:
7.         dist[v] = ‚àû
8.         prev[v] = undefined
9.     dist[source] = 0
     
10.    while Q is not empty:
11.        u = node in Q with smallest dist[u]
12.        remove u from Q

13.        for each neighbor v of u:
14.            alt = dist[u] + weight(u, v)
15.            if alt < dist[v]:
16.                dist[v] = alt
17.                prev[v] = u
18.                update Q with new dist[v]
     
19.    return dist, prev
```

---

### Tiefgang 4 von Lupera (J) nach Eindhofen (E)

1. **Starte in der Stadt J**:
   - Markiere die Stadt **J** **rot** und weise ihr die Kennzahl **0** zu.
   - Bezeichne **J** als **aktuelle Stadt**.

2. **Bearbeite alle Nachbarst√§dte der aktuellen Stadt**:
   - Gehe zu allen direkt erreichbaren **Nachbarst√§dten**, die **noch nicht rot markiert** sind.
   - F√ºhre f√ºr jede Nachbarstadt die folgenden Schritte aus:
     1. Berechne die **Summe** aus der Kennzahl der aktuellen Stadt (rote Zahl) und der **Streckenl√§nge** zur Nachbarstadt.
     2. √úberpr√ºfe die Nachbarstadt:
        - **Keine Kennzahl vorhanden**: Weise die berechnete Summe als neue Kennzahl zu. Markiere die Strecke zur aktuellen Stadt.
        - **Kennzahl kleiner oder gleich der Summe**: Nichts tun.
        - **Kennzahl gr√∂√üer als die Summe**: L√∂sche die bisherige Kennzahl und die Markierung zur bisherigen Stadt. Markiere die Strecke zur aktuellen Stadt neu.

3. **W√§hle die n√§chste Stadt**:
   - Betrachte alle St√§dte, die bereits eine **rote Kennzahl** haben, aber noch nicht **rot markiert** sind.
   - Suche die Stadt mit der **kleinsten Kennzahl**.
     - Falls mehrere St√§dte die **gleiche kleinste Kennzahl** haben, w√§hle eine davon **beliebig** aus.

4. **Markiere die n√§chste Stadt**:
   - Bezeichne die Stadt mit der kleinsten Kennzahl als **aktuelle Stadt**.
   - Markiere die Stadt **rot** und zeichne die zugeh√∂rige Strecke komplett **rot** nach.

5. **√úberpr√ºfe das Ziel**:
   - Falls die **Zielstadt E** noch **nicht rot markiert** ist, kehre zur√ºck zu **Schritt 2** (While-Loop).

6. **Ende des Algorithmus**:
   - Sobald die Zielstadt **E rot markiert** ist, endet der Algorithmus.
   - Der k√ºrzeste Weg von Stadt **J** nach Stadt **E** wurde erfolgreich gefunden.

---

#### Grafische Darstellung  

```mermaid
flowchart TD
    A[Quickstedt]
    B[Oppenheim]
    C[Pappstadt]
    D[Fluxing]
    E[Eindhofen]
    F[Imstadt]
    G[Hundorf]
    H[Krusping]
    I[Giwelau]
    J((Lupera)):::red
    K[Budingen]
    L[Morbach]
    M[Chelzey]
    N[Delgar]
    O[Arlhausen]
    P[Niedergau]
    AK1(Autobahnkreuz 1)
    AK2(Autobahnkreuz 2):::visited
    AK3(Autobahnkreuz 3)

    J -->|7,8| AK2:::red
    J -->|18,9| N
    AK2 -->|6,2| K:::red
    K -->|4,9| AK3:::red
    AK3 -->|6,4| O:::red
    O -->|5,8| E:::target

    A -->|5,3| B
    B -->|18,2| C
    B -->|2,9| D
    B -->|19,5| E
    C -->|11,6| D
    C -->|15,4| F
    C -->|10,5| F
    C -->|7,1| G
    C -->|7,1| H
    D -->|15,6| E
    D -->|6,1| H
    E -->|12,1| I
    E -->|6,2| H
    F -->|13,4| G
    F -->|7,0| K
    F -->|9,0| L
    F -->|9,0| M
    G --> |6,0| H
    G --> |5,9| AK1 
    G --> |21,1| J 
    G --> |5,6| K
    H --> |11,5| I
    H --> |3,6| AK1
    I --> |11,8| J
    I --> |5,5| AK1
    K --> |13,0| N
    K --> |14,3| O
    L --> |5,6| M
    L --> |6,7| O
    L --> |2,3| AK3
    M --> |4,6| AK3
    N --> |2,5| N
    N --> |6,6| O
    N --> |4,1| P
    O --> |3,8| P
    AK1 --> |4,5| AK2

    classDef start fill:#ff0000,stroke:#900,stroke-width:3px;
    classDef visited fill:#ffcccc,stroke:#900,stroke-width:2px;
    classDef red fill:#ff4444,stroke:#900,stroke-width:2px;
    classDef target fill:#00ff00,stroke:#080,stroke-width:3px;

```

### Tiefgang 5

## Exkurs Graph 
```
    o
   /|\
  o-o-o
   \|/
    o
```
**O** steht f√ºr die Knoten.

**Kanten** verbinden jeden Knoten mit jedem anderen.

---

**F√ºr ùëõ = 7:** Die Anzahl m√∂glicher Wege, die bei einem Startpunkt beginnen, ergibt sich aus ( ùëõ ‚àí 1 ) ! = 6 !.  
6 ! = 6 ‚ãÖ 5 ‚ãÖ 4 ‚ãÖ 3 ‚ãÖ 2 ‚ãÖ 1 = 720.  
Um alle m√∂glichen Wege zu erfassen, muss dies ùëõ ‚àí 1 mal durchgef√ºhrt werden, da der Startpunkt jedes Mal unterschiedlich gew√§hlt werden kann:  
**Formel:** ( ùëõ ‚àí 1 ) ‚ãÖ ( ùëõ ‚àí 1 ) ! = 6 ‚ãÖ 720 = 4320.

---

**Die Formel lautetüî¢** ( ùëõ ‚àí 1 ) ‚ãÖ ( ùëõ ‚àí 1 ) !:  
F√ºr ùëõ = 10: ( 10 ‚àí 1 ) ‚ãÖ ( 10 ‚àí 1 ) ! = 9 ‚ãÖ 9 ! = 9 ‚ãÖ 362,880 = 3,265,920.  
F√ºr ùëõ = 20: ( 20 ‚àí 1 ) ‚ãÖ ( 20 ‚àí 1 ) ! = 19 ‚ãÖ 19 !.  
Zun√§chst berechnen wir 19 !:  
19 ! = 19 ‚ãÖ 18 ‚ãÖ 17 ‚ãÖ ‚ãØ ‚ãÖ 1 = 121,645,100,408,832,000.  
Dann multiplizieren wir mit 19:  
19 ‚ãÖ 19 ! = 2,310,079,200,000,000,000.

---

**Ein Googol ‚àû** ist eine sehr gro√üe Zahl, die als 10^100 definiert ist, also eine 1 gefolgt von 100 Nullen. Sie wurde von Mathematiker Edward Kasner eingef√ºhrt, um extrem gro√üe Zahlen zu veranschaulichen. Ein Googol ist viel gr√∂√üer als die Anzahl der Atome im sichtbaren Universum. Der Begriff wurde auch als Inspiration f√ºr den Namen der Suchmaschine Google verwendet.

---

**Berechnung üìà** f√ºr ùëõ = 7:  
Summe = ( 7 ‚àí 1 ) ‚ãÖ 7¬≤ = 6 ‚ãÖ 49 = 294.  
Der Dijkstra-Algorithmus ben√∂tigt f√ºr ùëõ = 7 also 21 Schritte.

---

**Berechnung üìà** f√ºr ùëõ = 15:  
Summe = ( 15 ‚àí 1 ) ‚ãÖ 15¬≤ = 14 ‚ãÖ 225 = 3150.  
Der Dijkstra-Algorithmus ben√∂tigt f√ºr ùëõ = 15 also 105 Schritte.

---

**Vergleich üîç** mit der Abbildung ‚ÄûKnoten M√∂glichkeiten Dijkstra‚Äú:  
Die Abbildung sollte f√ºr ùëõ = 7 den Wert 21 und f√ºr ùëõ = 15 den Wert 105 angeben.  
Diese Werte resultieren aus der Summenformel und stellen den reduzierten Aufwand dar, im Vergleich zu der Anzahl an Permutationen beim Brute-Force-Ansatz.

---

**Zusammenfassungüìù**  
F√ºr ùëõ = 7: 21 Schritte.  
F√ºr ùëõ = 15: 105 Schritte.  
Der Aufwand w√§chst hierbei linear, im Gegensatz zur exponentiellen Wachstumskurve beim Brute-Force-Ansatz.

---

**Das Travelling Salesman Problem üåê (TSP)**  
Das TSP ist ein bekanntes Problem in der Informatik und Mathematik. Dabei geht es darum, dass ein Handelsreisender den k√ºrzesten Weg finden soll, um eine bestimmte Anzahl von St√§dten genau einmal zu besuchen und am Ende wieder an den Ausgangspunkt zur√ºckzukehren.  
Das Problem wird oft in der Graphentheorie beschrieben, bei der St√§dte als Knoten und Verbindungen als Kanten dargestellt werden.

---

**Das TSP üåê** geh√∂rt zu den sogenannten NP-schweren Problemen. Das bedeutet, dass es sehr schwer ist, eine optimale L√∂sung f√ºr gro√üe Instanzen des Problems zu finden. F√ºr solche Probleme gibt es keine bekannten schnellen Algorithmen, die sie f√ºr beliebige Eingaben effizient l√∂sen k√∂nnen. Es wurde gezeigt, dass das TSP mit den NP-vollst√§ndigen Problemen verwandt ist, die ebenfalls zu den schwierigsten Problemen in der Informatik z√§hlen. Das macht das TSP besonders herausfordernd und gleichzeitig wichtig f√ºr viele Anwendungen wie Logistik, Routenplanung oder Netzwerkdesign.

---

**Die Frage üïµÔ∏è‚Äç‚ôÇÔ∏è P=NP?**  
ist eines der gr√∂√üten ungel√∂sten Probleme der Informatik. Es geht darum, ob Probleme, die sich leicht √ºberpr√ºfen lassen (NP), auch genauso leicht l√∂sbar sind (P). Bis heute hat niemand eine Antwort darauf gefunden.

---

**Falls sich ü§î herausstellen w√ºrde, dass P=NP**, k√∂nnten komplexe Probleme wie das Travelling Salesman Problem effizient gel√∂st werden.  
Der Text macht aber auch deutlich, dass "NP" eigentlich nicht "nicht praktisch l√∂sbar" bedeutet, sondern "nichtdeterministisch polynomial l√∂sbar". In der Praxis bedeutet das, dass reale Computer Schwierigkeiten h√§tten, diese Probleme schnell zu l√∂sen, selbst wenn P=NP bewiesen w√ºrde.

---

**Zusammengefasstüìù:**  
Die Frage ist eine der wichtigsten Herausforderungen in der Informatik und k√∂nnte viele schwierige Probleme auf einmal kl√§ren.


**Berechneüìà** nun die Zeit f√ºr eine Fahrt von Imstadt nach Budingen


## Berechnung der Fahrzeiten

Wir berechnen die Fahrzeiten f√ºr die verschiedenen Streckenabschnitte, wobei wir die Geschwindigkeit und m√∂gliche Ortsdurchfahrten ber√ºcksichtigen.

### Gegebene Geschwindigkeiten:
- **Autobahnen**: 130 km/h
- **Landstra√üe** (gelb, rot): 80 km/h
- **Gemeindestra√üen** (wei√ü): 50 km/h
- **Ortsdurchfahrten**: Zus√§tzliche 8 Minuten (gilt auch bei Autobahnen, wenn sie einen Ort durchqueren)

### Fahrzeitberechnung

Die **Fahrzeit (in Stunden)** wird berechnet mit der Formel:

$$
\text{Fahrzeit (in Stunden)} = \frac{\text{Streckenl√§nge (in km)}}{\text{Geschwindigkeit (in km/h)}}
$$

Falls die Strecke durch eine **Ortsdurchfahrt** f√ºhrt, f√ºgen wir 8 Minuten hinzu.

#### 1. Imstadt nach Budingen (7 km, Landstra√üe, 80 km/h)

$$
\text{Fahrzeit} = \frac{7 \, \text{km}}{80 \, \text{km/h}} = 0,0875 \, \text{Stunden} = 5,25 \, \text{Minuten}
$$

#### 2. Imstadt nach Chelzey (8,2 km, Gemeindestra√üe, 50 km/h)

$$
\text{Fahrzeit} = \frac{8,2 \, \text{km}}{50 \, \text{km/h}} = 0,164 \, \text{Stunden} = 9,84 \, \text{Minuten}
$$

#### 3. Imstadt nach Morbach (9,0 km, Landstra√üe, 80 km/h)

$$
\text{Fahrzeit} = \frac{9,0 \, \text{km}}{80 \, \text{km/h}} = 0,1125 \, \text{Stunden} = 6,75 \, \text{Minuten}
$$

#### 4. Imstadt nach Hundorf (13,4 km, Gemeindestra√üe, 50 km/h)

$$
\text{Fahrzeit} = \frac{13,4 \, \text{km}}{50 \, \text{km/h}} = 0,268 \, \text{Stunden} = 16,08 \, \text{Minuten}
$$

#### 5. Imstadt nach Pappstadt (10,5 km, Landstra√üe, 80 km/h)

$$
\text{Fahrzeit} = \frac{10,5 \, \text{km}}{80 \, \text{km/h}} = 0,13125 \, \text{Stunden} = 7,875 \, \text{Minuten}
$$

### Hinweis zu Ortsdurchfahrten:
Falls eine der Strecken eine Ortsdurchfahrt enth√§lt, m√ºssen wir zus√§tzlich 8 Minuten ber√ºcksichtigen. Wir haben diese Information aber noch nicht f√ºr jede Strecke.

